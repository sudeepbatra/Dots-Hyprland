// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::Object;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "AtkTable")]
    pub struct Table(Interface<ffi::AtkTable, ffi::AtkTableIface>);

    match fn {
        type_ => || ffi::atk_table_get_type(),
    }
}

pub const NONE_TABLE: Option<&Table> = None;

pub trait TableExt: 'static {
    #[doc(alias = "atk_table_add_column_selection")]
    fn add_column_selection(&self, column: i32) -> bool;

    #[doc(alias = "atk_table_add_row_selection")]
    fn add_row_selection(&self, row: i32) -> bool;

    #[doc(alias = "atk_table_get_caption")]
    #[doc(alias = "get_caption")]
    fn caption(&self) -> Option<Object>;

    #[doc(alias = "atk_table_get_column_at_index")]
    #[doc(alias = "get_column_at_index")]
    fn column_at_index(&self, index_: i32) -> i32;

    #[doc(alias = "atk_table_get_column_description")]
    #[doc(alias = "get_column_description")]
    fn column_description(&self, column: i32) -> Option<glib::GString>;

    #[doc(alias = "atk_table_get_column_extent_at")]
    #[doc(alias = "get_column_extent_at")]
    fn column_extent_at(&self, row: i32, column: i32) -> i32;

    #[doc(alias = "atk_table_get_column_header")]
    #[doc(alias = "get_column_header")]
    fn column_header(&self, column: i32) -> Option<Object>;

    #[doc(alias = "atk_table_get_index_at")]
    #[doc(alias = "get_index_at")]
    fn index_at(&self, row: i32, column: i32) -> i32;

    #[doc(alias = "atk_table_get_n_columns")]
    #[doc(alias = "get_n_columns")]
    fn n_columns(&self) -> i32;

    #[doc(alias = "atk_table_get_n_rows")]
    #[doc(alias = "get_n_rows")]
    fn n_rows(&self) -> i32;

    #[doc(alias = "atk_table_get_row_at_index")]
    #[doc(alias = "get_row_at_index")]
    fn row_at_index(&self, index_: i32) -> i32;

    #[doc(alias = "atk_table_get_row_description")]
    #[doc(alias = "get_row_description")]
    fn row_description(&self, row: i32) -> Option<glib::GString>;

    #[doc(alias = "atk_table_get_row_extent_at")]
    #[doc(alias = "get_row_extent_at")]
    fn row_extent_at(&self, row: i32, column: i32) -> i32;

    #[doc(alias = "atk_table_get_row_header")]
    #[doc(alias = "get_row_header")]
    fn row_header(&self, row: i32) -> Option<Object>;

    #[doc(alias = "atk_table_get_summary")]
    #[doc(alias = "get_summary")]
    fn summary(&self) -> Option<Object>;

    #[doc(alias = "atk_table_is_column_selected")]
    fn is_column_selected(&self, column: i32) -> bool;

    #[doc(alias = "atk_table_is_row_selected")]
    fn is_row_selected(&self, row: i32) -> bool;

    #[doc(alias = "atk_table_is_selected")]
    fn is_selected(&self, row: i32, column: i32) -> bool;

    #[doc(alias = "atk_table_ref_at")]
    fn ref_at(&self, row: i32, column: i32) -> Option<Object>;

    #[doc(alias = "atk_table_remove_column_selection")]
    fn remove_column_selection(&self, column: i32) -> bool;

    #[doc(alias = "atk_table_remove_row_selection")]
    fn remove_row_selection(&self, row: i32) -> bool;

    #[doc(alias = "atk_table_set_caption")]
    fn set_caption<P: IsA<Object>>(&self, caption: &P);

    #[doc(alias = "atk_table_set_column_description")]
    fn set_column_description(&self, column: i32, description: &str);

    #[doc(alias = "atk_table_set_column_header")]
    fn set_column_header<P: IsA<Object>>(&self, column: i32, header: &P);

    #[doc(alias = "atk_table_set_row_description")]
    fn set_row_description(&self, row: i32, description: &str);

    #[doc(alias = "atk_table_set_row_header")]
    fn set_row_header<P: IsA<Object>>(&self, row: i32, header: &P);

    #[doc(alias = "atk_table_set_summary")]
    fn set_summary<P: IsA<Object>>(&self, accessible: &P);

    #[doc(alias = "column-deleted")]
    fn connect_column_deleted<F: Fn(&Self, i32, i32) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "column-inserted")]
    fn connect_column_inserted<F: Fn(&Self, i32, i32) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "column-reordered")]
    fn connect_column_reordered<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "model-changed")]
    fn connect_model_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "row-deleted")]
    fn connect_row_deleted<F: Fn(&Self, i32, i32) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "row-inserted")]
    fn connect_row_inserted<F: Fn(&Self, i32, i32) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "row-reordered")]
    fn connect_row_reordered<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Table>> TableExt for O {
    fn add_column_selection(&self, column: i32) -> bool {
        unsafe {
            from_glib(ffi::atk_table_add_column_selection(
                self.as_ref().to_glib_none().0,
                column,
            ))
        }
    }

    fn add_row_selection(&self, row: i32) -> bool {
        unsafe {
            from_glib(ffi::atk_table_add_row_selection(
                self.as_ref().to_glib_none().0,
                row,
            ))
        }
    }

    fn caption(&self) -> Option<Object> {
        unsafe { from_glib_none(ffi::atk_table_get_caption(self.as_ref().to_glib_none().0)) }
    }

    fn column_at_index(&self, index_: i32) -> i32 {
        unsafe { ffi::atk_table_get_column_at_index(self.as_ref().to_glib_none().0, index_) }
    }

    fn column_description(&self, column: i32) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::atk_table_get_column_description(
                self.as_ref().to_glib_none().0,
                column,
            ))
        }
    }

    fn column_extent_at(&self, row: i32, column: i32) -> i32 {
        unsafe { ffi::atk_table_get_column_extent_at(self.as_ref().to_glib_none().0, row, column) }
    }

    fn column_header(&self, column: i32) -> Option<Object> {
        unsafe {
            from_glib_none(ffi::atk_table_get_column_header(
                self.as_ref().to_glib_none().0,
                column,
            ))
        }
    }

    fn index_at(&self, row: i32, column: i32) -> i32 {
        unsafe { ffi::atk_table_get_index_at(self.as_ref().to_glib_none().0, row, column) }
    }

    fn n_columns(&self) -> i32 {
        unsafe { ffi::atk_table_get_n_columns(self.as_ref().to_glib_none().0) }
    }

    fn n_rows(&self) -> i32 {
        unsafe { ffi::atk_table_get_n_rows(self.as_ref().to_glib_none().0) }
    }

    fn row_at_index(&self, index_: i32) -> i32 {
        unsafe { ffi::atk_table_get_row_at_index(self.as_ref().to_glib_none().0, index_) }
    }

    fn row_description(&self, row: i32) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::atk_table_get_row_description(
                self.as_ref().to_glib_none().0,
                row,
            ))
        }
    }

    fn row_extent_at(&self, row: i32, column: i32) -> i32 {
        unsafe { ffi::atk_table_get_row_extent_at(self.as_ref().to_glib_none().0, row, column) }
    }

    fn row_header(&self, row: i32) -> Option<Object> {
        unsafe {
            from_glib_none(ffi::atk_table_get_row_header(
                self.as_ref().to_glib_none().0,
                row,
            ))
        }
    }

    fn summary(&self) -> Option<Object> {
        unsafe { from_glib_full(ffi::atk_table_get_summary(self.as_ref().to_glib_none().0)) }
    }

    fn is_column_selected(&self, column: i32) -> bool {
        unsafe {
            from_glib(ffi::atk_table_is_column_selected(
                self.as_ref().to_glib_none().0,
                column,
            ))
        }
    }

    fn is_row_selected(&self, row: i32) -> bool {
        unsafe {
            from_glib(ffi::atk_table_is_row_selected(
                self.as_ref().to_glib_none().0,
                row,
            ))
        }
    }

    fn is_selected(&self, row: i32, column: i32) -> bool {
        unsafe {
            from_glib(ffi::atk_table_is_selected(
                self.as_ref().to_glib_none().0,
                row,
                column,
            ))
        }
    }

    fn ref_at(&self, row: i32, column: i32) -> Option<Object> {
        unsafe {
            from_glib_full(ffi::atk_table_ref_at(
                self.as_ref().to_glib_none().0,
                row,
                column,
            ))
        }
    }

    fn remove_column_selection(&self, column: i32) -> bool {
        unsafe {
            from_glib(ffi::atk_table_remove_column_selection(
                self.as_ref().to_glib_none().0,
                column,
            ))
        }
    }

    fn remove_row_selection(&self, row: i32) -> bool {
        unsafe {
            from_glib(ffi::atk_table_remove_row_selection(
                self.as_ref().to_glib_none().0,
                row,
            ))
        }
    }

    fn set_caption<P: IsA<Object>>(&self, caption: &P) {
        unsafe {
            ffi::atk_table_set_caption(
                self.as_ref().to_glib_none().0,
                caption.as_ref().to_glib_none().0,
            );
        }
    }

    fn set_column_description(&self, column: i32, description: &str) {
        unsafe {
            ffi::atk_table_set_column_description(
                self.as_ref().to_glib_none().0,
                column,
                description.to_glib_none().0,
            );
        }
    }

    fn set_column_header<P: IsA<Object>>(&self, column: i32, header: &P) {
        unsafe {
            ffi::atk_table_set_column_header(
                self.as_ref().to_glib_none().0,
                column,
                header.as_ref().to_glib_none().0,
            );
        }
    }

    fn set_row_description(&self, row: i32, description: &str) {
        unsafe {
            ffi::atk_table_set_row_description(
                self.as_ref().to_glib_none().0,
                row,
                description.to_glib_none().0,
            );
        }
    }

    fn set_row_header<P: IsA<Object>>(&self, row: i32, header: &P) {
        unsafe {
            ffi::atk_table_set_row_header(
                self.as_ref().to_glib_none().0,
                row,
                header.as_ref().to_glib_none().0,
            );
        }
    }

    fn set_summary<P: IsA<Object>>(&self, accessible: &P) {
        unsafe {
            ffi::atk_table_set_summary(
                self.as_ref().to_glib_none().0,
                accessible.as_ref().to_glib_none().0,
            );
        }
    }

    fn connect_column_deleted<F: Fn(&Self, i32, i32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn column_deleted_trampoline<
            P: IsA<Table>,
            F: Fn(&P, i32, i32) + 'static,
        >(
            this: *mut ffi::AtkTable,
            arg1: libc::c_int,
            arg2: libc::c_int,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Table::from_glib_borrow(this).unsafe_cast_ref(), arg1, arg2)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"column-deleted\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    column_deleted_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_column_inserted<F: Fn(&Self, i32, i32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn column_inserted_trampoline<
            P: IsA<Table>,
            F: Fn(&P, i32, i32) + 'static,
        >(
            this: *mut ffi::AtkTable,
            arg1: libc::c_int,
            arg2: libc::c_int,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Table::from_glib_borrow(this).unsafe_cast_ref(), arg1, arg2)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"column-inserted\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    column_inserted_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_column_reordered<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn column_reordered_trampoline<P: IsA<Table>, F: Fn(&P) + 'static>(
            this: *mut ffi::AtkTable,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Table::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"column-reordered\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    column_reordered_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_model_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn model_changed_trampoline<P: IsA<Table>, F: Fn(&P) + 'static>(
            this: *mut ffi::AtkTable,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Table::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"model-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    model_changed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_row_deleted<F: Fn(&Self, i32, i32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn row_deleted_trampoline<
            P: IsA<Table>,
            F: Fn(&P, i32, i32) + 'static,
        >(
            this: *mut ffi::AtkTable,
            arg1: libc::c_int,
            arg2: libc::c_int,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Table::from_glib_borrow(this).unsafe_cast_ref(), arg1, arg2)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"row-deleted\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    row_deleted_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_row_inserted<F: Fn(&Self, i32, i32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn row_inserted_trampoline<
            P: IsA<Table>,
            F: Fn(&P, i32, i32) + 'static,
        >(
            this: *mut ffi::AtkTable,
            arg1: libc::c_int,
            arg2: libc::c_int,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Table::from_glib_borrow(this).unsafe_cast_ref(), arg1, arg2)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"row-inserted\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    row_inserted_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    fn connect_row_reordered<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn row_reordered_trampoline<P: IsA<Table>, F: Fn(&P) + 'static>(
            this: *mut ffi::AtkTable,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Table::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"row-reordered\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    row_reordered_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl fmt::Display for Table {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Table")
    }
}
