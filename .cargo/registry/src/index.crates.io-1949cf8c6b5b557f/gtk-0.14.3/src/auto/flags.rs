// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use bitflags::bitflags;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::StaticType;
use glib::Type;
use std::fmt;

bitflags! {
    #[doc(alias = "GtkAccelFlags")]
    pub struct AccelFlags: u32 {
        #[doc(alias = "GTK_ACCEL_VISIBLE")]
        const VISIBLE = ffi::GTK_ACCEL_VISIBLE as u32;
        #[doc(alias = "GTK_ACCEL_LOCKED")]
        const LOCKED = ffi::GTK_ACCEL_LOCKED as u32;
        #[doc(alias = "GTK_ACCEL_MASK")]
        const MASK = ffi::GTK_ACCEL_MASK as u32;
    }
}

impl fmt::Display for AccelFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for AccelFlags {
    type GlibType = ffi::GtkAccelFlags;

    fn into_glib(self) -> ffi::GtkAccelFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAccelFlags> for AccelFlags {
    unsafe fn from_glib(value: ffi::GtkAccelFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for AccelFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_accel_flags_get_type()) }
    }
}

impl glib::value::ValueType for AccelFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for AccelFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for AccelFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkApplicationInhibitFlags")]
    pub struct ApplicationInhibitFlags: u32 {
        #[doc(alias = "GTK_APPLICATION_INHIBIT_LOGOUT")]
        const LOGOUT = ffi::GTK_APPLICATION_INHIBIT_LOGOUT as u32;
        #[doc(alias = "GTK_APPLICATION_INHIBIT_SWITCH")]
        const SWITCH = ffi::GTK_APPLICATION_INHIBIT_SWITCH as u32;
        #[doc(alias = "GTK_APPLICATION_INHIBIT_SUSPEND")]
        const SUSPEND = ffi::GTK_APPLICATION_INHIBIT_SUSPEND as u32;
        #[doc(alias = "GTK_APPLICATION_INHIBIT_IDLE")]
        const IDLE = ffi::GTK_APPLICATION_INHIBIT_IDLE as u32;
    }
}

impl fmt::Display for ApplicationInhibitFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for ApplicationInhibitFlags {
    type GlibType = ffi::GtkApplicationInhibitFlags;

    fn into_glib(self) -> ffi::GtkApplicationInhibitFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkApplicationInhibitFlags> for ApplicationInhibitFlags {
    unsafe fn from_glib(value: ffi::GtkApplicationInhibitFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ApplicationInhibitFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_application_inhibit_flags_get_type()) }
    }
}

impl glib::value::ValueType for ApplicationInhibitFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ApplicationInhibitFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ApplicationInhibitFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkCalendarDisplayOptions")]
    pub struct CalendarDisplayOptions: u32 {
        #[doc(alias = "GTK_CALENDAR_SHOW_HEADING")]
        const SHOW_HEADING = ffi::GTK_CALENDAR_SHOW_HEADING as u32;
        #[doc(alias = "GTK_CALENDAR_SHOW_DAY_NAMES")]
        const SHOW_DAY_NAMES = ffi::GTK_CALENDAR_SHOW_DAY_NAMES as u32;
        #[doc(alias = "GTK_CALENDAR_NO_MONTH_CHANGE")]
        const NO_MONTH_CHANGE = ffi::GTK_CALENDAR_NO_MONTH_CHANGE as u32;
        #[doc(alias = "GTK_CALENDAR_SHOW_WEEK_NUMBERS")]
        const SHOW_WEEK_NUMBERS = ffi::GTK_CALENDAR_SHOW_WEEK_NUMBERS as u32;
        #[doc(alias = "GTK_CALENDAR_SHOW_DETAILS")]
        const SHOW_DETAILS = ffi::GTK_CALENDAR_SHOW_DETAILS as u32;
    }
}

impl fmt::Display for CalendarDisplayOptions {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for CalendarDisplayOptions {
    type GlibType = ffi::GtkCalendarDisplayOptions;

    fn into_glib(self) -> ffi::GtkCalendarDisplayOptions {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCalendarDisplayOptions> for CalendarDisplayOptions {
    unsafe fn from_glib(value: ffi::GtkCalendarDisplayOptions) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for CalendarDisplayOptions {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_calendar_display_options_get_type()) }
    }
}

impl glib::value::ValueType for CalendarDisplayOptions {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CalendarDisplayOptions {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for CalendarDisplayOptions {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkCellRendererState")]
    pub struct CellRendererState: u32 {
        #[doc(alias = "GTK_CELL_RENDERER_SELECTED")]
        const SELECTED = ffi::GTK_CELL_RENDERER_SELECTED as u32;
        #[doc(alias = "GTK_CELL_RENDERER_PRELIT")]
        const PRELIT = ffi::GTK_CELL_RENDERER_PRELIT as u32;
        #[doc(alias = "GTK_CELL_RENDERER_INSENSITIVE")]
        const INSENSITIVE = ffi::GTK_CELL_RENDERER_INSENSITIVE as u32;
        #[doc(alias = "GTK_CELL_RENDERER_SORTED")]
        const SORTED = ffi::GTK_CELL_RENDERER_SORTED as u32;
        #[doc(alias = "GTK_CELL_RENDERER_FOCUSED")]
        const FOCUSED = ffi::GTK_CELL_RENDERER_FOCUSED as u32;
        #[doc(alias = "GTK_CELL_RENDERER_EXPANDABLE")]
        const EXPANDABLE = ffi::GTK_CELL_RENDERER_EXPANDABLE as u32;
        #[doc(alias = "GTK_CELL_RENDERER_EXPANDED")]
        const EXPANDED = ffi::GTK_CELL_RENDERER_EXPANDED as u32;
    }
}

impl fmt::Display for CellRendererState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for CellRendererState {
    type GlibType = ffi::GtkCellRendererState;

    fn into_glib(self) -> ffi::GtkCellRendererState {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCellRendererState> for CellRendererState {
    unsafe fn from_glib(value: ffi::GtkCellRendererState) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for CellRendererState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_cell_renderer_state_get_type()) }
    }
}

impl glib::value::ValueType for CellRendererState {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CellRendererState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for CellRendererState {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkDestDefaults")]
    pub struct DestDefaults: u32 {
        #[doc(alias = "GTK_DEST_DEFAULT_MOTION")]
        const MOTION = ffi::GTK_DEST_DEFAULT_MOTION as u32;
        #[doc(alias = "GTK_DEST_DEFAULT_HIGHLIGHT")]
        const HIGHLIGHT = ffi::GTK_DEST_DEFAULT_HIGHLIGHT as u32;
        #[doc(alias = "GTK_DEST_DEFAULT_DROP")]
        const DROP = ffi::GTK_DEST_DEFAULT_DROP as u32;
        #[doc(alias = "GTK_DEST_DEFAULT_ALL")]
        const ALL = ffi::GTK_DEST_DEFAULT_ALL as u32;
    }
}

impl fmt::Display for DestDefaults {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for DestDefaults {
    type GlibType = ffi::GtkDestDefaults;

    fn into_glib(self) -> ffi::GtkDestDefaults {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDestDefaults> for DestDefaults {
    unsafe fn from_glib(value: ffi::GtkDestDefaults) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DestDefaults {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_dest_defaults_get_type()) }
    }
}

impl glib::value::ValueType for DestDefaults {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DestDefaults {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DestDefaults {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkDialogFlags")]
    pub struct DialogFlags: u32 {
        #[doc(alias = "GTK_DIALOG_MODAL")]
        const MODAL = ffi::GTK_DIALOG_MODAL as u32;
        #[doc(alias = "GTK_DIALOG_DESTROY_WITH_PARENT")]
        const DESTROY_WITH_PARENT = ffi::GTK_DIALOG_DESTROY_WITH_PARENT as u32;
        #[doc(alias = "GTK_DIALOG_USE_HEADER_BAR")]
        const USE_HEADER_BAR = ffi::GTK_DIALOG_USE_HEADER_BAR as u32;
    }
}

impl fmt::Display for DialogFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for DialogFlags {
    type GlibType = ffi::GtkDialogFlags;

    fn into_glib(self) -> ffi::GtkDialogFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDialogFlags> for DialogFlags {
    unsafe fn from_glib(value: ffi::GtkDialogFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DialogFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_dialog_flags_get_type()) }
    }
}

impl glib::value::ValueType for DialogFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DialogFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DialogFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
    #[doc(alias = "GtkEventControllerScrollFlags")]
    pub struct EventControllerScrollFlags: u32 {
        #[doc(alias = "GTK_EVENT_CONTROLLER_SCROLL_NONE")]
        const NONE = ffi::GTK_EVENT_CONTROLLER_SCROLL_NONE as u32;
        #[doc(alias = "GTK_EVENT_CONTROLLER_SCROLL_VERTICAL")]
        const VERTICAL = ffi::GTK_EVENT_CONTROLLER_SCROLL_VERTICAL as u32;
        #[doc(alias = "GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL")]
        const HORIZONTAL = ffi::GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL as u32;
        #[doc(alias = "GTK_EVENT_CONTROLLER_SCROLL_DISCRETE")]
        const DISCRETE = ffi::GTK_EVENT_CONTROLLER_SCROLL_DISCRETE as u32;
        #[doc(alias = "GTK_EVENT_CONTROLLER_SCROLL_KINETIC")]
        const KINETIC = ffi::GTK_EVENT_CONTROLLER_SCROLL_KINETIC as u32;
        #[doc(alias = "GTK_EVENT_CONTROLLER_SCROLL_BOTH_AXES")]
        const BOTH_AXES = ffi::GTK_EVENT_CONTROLLER_SCROLL_BOTH_AXES as u32;
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
impl fmt::Display for EventControllerScrollFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
#[doc(hidden)]
impl IntoGlib for EventControllerScrollFlags {
    type GlibType = ffi::GtkEventControllerScrollFlags;

    fn into_glib(self) -> ffi::GtkEventControllerScrollFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkEventControllerScrollFlags> for EventControllerScrollFlags {
    unsafe fn from_glib(value: ffi::GtkEventControllerScrollFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
impl StaticType for EventControllerScrollFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_event_controller_scroll_flags_get_type()) }
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
impl glib::value::ValueType for EventControllerScrollFlags {
    type Type = Self;
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
unsafe impl<'a> FromValue<'a> for EventControllerScrollFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
impl ToValue for EventControllerScrollFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkFileFilterFlags")]
    pub struct FileFilterFlags: u32 {
        #[doc(alias = "GTK_FILE_FILTER_FILENAME")]
        const FILENAME = ffi::GTK_FILE_FILTER_FILENAME as u32;
        #[doc(alias = "GTK_FILE_FILTER_URI")]
        const URI = ffi::GTK_FILE_FILTER_URI as u32;
        #[doc(alias = "GTK_FILE_FILTER_DISPLAY_NAME")]
        const DISPLAY_NAME = ffi::GTK_FILE_FILTER_DISPLAY_NAME as u32;
        #[doc(alias = "GTK_FILE_FILTER_MIME_TYPE")]
        const MIME_TYPE = ffi::GTK_FILE_FILTER_MIME_TYPE as u32;
    }
}

impl fmt::Display for FileFilterFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for FileFilterFlags {
    type GlibType = ffi::GtkFileFilterFlags;

    fn into_glib(self) -> ffi::GtkFileFilterFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileFilterFlags> for FileFilterFlags {
    unsafe fn from_glib(value: ffi::GtkFileFilterFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for FileFilterFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_file_filter_flags_get_type()) }
    }
}

impl glib::value::ValueType for FileFilterFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FileFilterFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for FileFilterFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
    #[doc(alias = "GtkFontChooserLevel")]
    pub struct FontChooserLevel: u32 {
        #[doc(alias = "GTK_FONT_CHOOSER_LEVEL_FAMILY")]
        const FAMILY = ffi::GTK_FONT_CHOOSER_LEVEL_FAMILY as u32;
        #[doc(alias = "GTK_FONT_CHOOSER_LEVEL_STYLE")]
        const STYLE = ffi::GTK_FONT_CHOOSER_LEVEL_STYLE as u32;
        #[doc(alias = "GTK_FONT_CHOOSER_LEVEL_SIZE")]
        const SIZE = ffi::GTK_FONT_CHOOSER_LEVEL_SIZE as u32;
        #[doc(alias = "GTK_FONT_CHOOSER_LEVEL_VARIATIONS")]
        const VARIATIONS = ffi::GTK_FONT_CHOOSER_LEVEL_VARIATIONS as u32;
        #[doc(alias = "GTK_FONT_CHOOSER_LEVEL_FEATURES")]
        const FEATURES = ffi::GTK_FONT_CHOOSER_LEVEL_FEATURES as u32;
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
impl fmt::Display for FontChooserLevel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
#[doc(hidden)]
impl IntoGlib for FontChooserLevel {
    type GlibType = ffi::GtkFontChooserLevel;

    fn into_glib(self) -> ffi::GtkFontChooserLevel {
        self.bits()
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkFontChooserLevel> for FontChooserLevel {
    unsafe fn from_glib(value: ffi::GtkFontChooserLevel) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
impl StaticType for FontChooserLevel {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_font_chooser_level_get_type()) }
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
impl glib::value::ValueType for FontChooserLevel {
    type Type = Self;
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
unsafe impl<'a> FromValue<'a> for FontChooserLevel {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v3_24", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_24")))]
impl ToValue for FontChooserLevel {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkIconLookupFlags")]
    pub struct IconLookupFlags: u32 {
        #[doc(alias = "GTK_ICON_LOOKUP_NO_SVG")]
        const NO_SVG = ffi::GTK_ICON_LOOKUP_NO_SVG as u32;
        #[doc(alias = "GTK_ICON_LOOKUP_FORCE_SVG")]
        const FORCE_SVG = ffi::GTK_ICON_LOOKUP_FORCE_SVG as u32;
        #[doc(alias = "GTK_ICON_LOOKUP_USE_BUILTIN")]
        const USE_BUILTIN = ffi::GTK_ICON_LOOKUP_USE_BUILTIN as u32;
        #[doc(alias = "GTK_ICON_LOOKUP_GENERIC_FALLBACK")]
        const GENERIC_FALLBACK = ffi::GTK_ICON_LOOKUP_GENERIC_FALLBACK as u32;
        #[doc(alias = "GTK_ICON_LOOKUP_FORCE_SIZE")]
        const FORCE_SIZE = ffi::GTK_ICON_LOOKUP_FORCE_SIZE as u32;
        #[doc(alias = "GTK_ICON_LOOKUP_FORCE_REGULAR")]
        const FORCE_REGULAR = ffi::GTK_ICON_LOOKUP_FORCE_REGULAR as u32;
        #[doc(alias = "GTK_ICON_LOOKUP_FORCE_SYMBOLIC")]
        const FORCE_SYMBOLIC = ffi::GTK_ICON_LOOKUP_FORCE_SYMBOLIC as u32;
        #[doc(alias = "GTK_ICON_LOOKUP_DIR_LTR")]
        const DIR_LTR = ffi::GTK_ICON_LOOKUP_DIR_LTR as u32;
        #[doc(alias = "GTK_ICON_LOOKUP_DIR_RTL")]
        const DIR_RTL = ffi::GTK_ICON_LOOKUP_DIR_RTL as u32;
    }
}

impl fmt::Display for IconLookupFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for IconLookupFlags {
    type GlibType = ffi::GtkIconLookupFlags;

    fn into_glib(self) -> ffi::GtkIconLookupFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconLookupFlags> for IconLookupFlags {
    unsafe fn from_glib(value: ffi::GtkIconLookupFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for IconLookupFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_icon_lookup_flags_get_type()) }
    }
}

impl glib::value::ValueType for IconLookupFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for IconLookupFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for IconLookupFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkInputHints")]
    pub struct InputHints: u32 {
        #[doc(alias = "GTK_INPUT_HINT_NONE")]
        const NONE = ffi::GTK_INPUT_HINT_NONE as u32;
        #[doc(alias = "GTK_INPUT_HINT_SPELLCHECK")]
        const SPELLCHECK = ffi::GTK_INPUT_HINT_SPELLCHECK as u32;
        #[doc(alias = "GTK_INPUT_HINT_NO_SPELLCHECK")]
        const NO_SPELLCHECK = ffi::GTK_INPUT_HINT_NO_SPELLCHECK as u32;
        #[doc(alias = "GTK_INPUT_HINT_WORD_COMPLETION")]
        const WORD_COMPLETION = ffi::GTK_INPUT_HINT_WORD_COMPLETION as u32;
        #[doc(alias = "GTK_INPUT_HINT_LOWERCASE")]
        const LOWERCASE = ffi::GTK_INPUT_HINT_LOWERCASE as u32;
        #[doc(alias = "GTK_INPUT_HINT_UPPERCASE_CHARS")]
        const UPPERCASE_CHARS = ffi::GTK_INPUT_HINT_UPPERCASE_CHARS as u32;
        #[doc(alias = "GTK_INPUT_HINT_UPPERCASE_WORDS")]
        const UPPERCASE_WORDS = ffi::GTK_INPUT_HINT_UPPERCASE_WORDS as u32;
        #[doc(alias = "GTK_INPUT_HINT_UPPERCASE_SENTENCES")]
        const UPPERCASE_SENTENCES = ffi::GTK_INPUT_HINT_UPPERCASE_SENTENCES as u32;
        #[doc(alias = "GTK_INPUT_HINT_INHIBIT_OSK")]
        const INHIBIT_OSK = ffi::GTK_INPUT_HINT_INHIBIT_OSK as u32;
        #[doc(alias = "GTK_INPUT_HINT_VERTICAL_WRITING")]
        const VERTICAL_WRITING = ffi::GTK_INPUT_HINT_VERTICAL_WRITING as u32;
        #[cfg(any(feature = "v3_22_20", feature = "dox"))]
        #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_22_20")))]
        #[doc(alias = "GTK_INPUT_HINT_EMOJI")]
        const EMOJI = ffi::GTK_INPUT_HINT_EMOJI as u32;
        #[cfg(any(feature = "v3_22_20", feature = "dox"))]
        #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_22_20")))]
        #[doc(alias = "GTK_INPUT_HINT_NO_EMOJI")]
        const NO_EMOJI = ffi::GTK_INPUT_HINT_NO_EMOJI as u32;
    }
}

impl fmt::Display for InputHints {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for InputHints {
    type GlibType = ffi::GtkInputHints;

    fn into_glib(self) -> ffi::GtkInputHints {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkInputHints> for InputHints {
    unsafe fn from_glib(value: ffi::GtkInputHints) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for InputHints {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_input_hints_get_type()) }
    }
}

impl glib::value::ValueType for InputHints {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for InputHints {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for InputHints {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkJunctionSides")]
    pub struct JunctionSides: u32 {
        #[doc(alias = "GTK_JUNCTION_NONE")]
        const NONE = ffi::GTK_JUNCTION_NONE as u32;
        #[doc(alias = "GTK_JUNCTION_CORNER_TOPLEFT")]
        const CORNER_TOPLEFT = ffi::GTK_JUNCTION_CORNER_TOPLEFT as u32;
        #[doc(alias = "GTK_JUNCTION_CORNER_TOPRIGHT")]
        const CORNER_TOPRIGHT = ffi::GTK_JUNCTION_CORNER_TOPRIGHT as u32;
        #[doc(alias = "GTK_JUNCTION_CORNER_BOTTOMLEFT")]
        const CORNER_BOTTOMLEFT = ffi::GTK_JUNCTION_CORNER_BOTTOMLEFT as u32;
        #[doc(alias = "GTK_JUNCTION_CORNER_BOTTOMRIGHT")]
        const CORNER_BOTTOMRIGHT = ffi::GTK_JUNCTION_CORNER_BOTTOMRIGHT as u32;
        #[doc(alias = "GTK_JUNCTION_TOP")]
        const TOP = ffi::GTK_JUNCTION_TOP as u32;
        #[doc(alias = "GTK_JUNCTION_BOTTOM")]
        const BOTTOM = ffi::GTK_JUNCTION_BOTTOM as u32;
        #[doc(alias = "GTK_JUNCTION_LEFT")]
        const LEFT = ffi::GTK_JUNCTION_LEFT as u32;
        #[doc(alias = "GTK_JUNCTION_RIGHT")]
        const RIGHT = ffi::GTK_JUNCTION_RIGHT as u32;
    }
}

impl fmt::Display for JunctionSides {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for JunctionSides {
    type GlibType = ffi::GtkJunctionSides;

    fn into_glib(self) -> ffi::GtkJunctionSides {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkJunctionSides> for JunctionSides {
    unsafe fn from_glib(value: ffi::GtkJunctionSides) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for JunctionSides {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_junction_sides_get_type()) }
    }
}

impl glib::value::ValueType for JunctionSides {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for JunctionSides {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for JunctionSides {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkPlacesOpenFlags")]
    pub struct PlacesOpenFlags: u32 {
        #[doc(alias = "GTK_PLACES_OPEN_NORMAL")]
        const NORMAL = ffi::GTK_PLACES_OPEN_NORMAL as u32;
        #[doc(alias = "GTK_PLACES_OPEN_NEW_TAB")]
        const NEW_TAB = ffi::GTK_PLACES_OPEN_NEW_TAB as u32;
        #[doc(alias = "GTK_PLACES_OPEN_NEW_WINDOW")]
        const NEW_WINDOW = ffi::GTK_PLACES_OPEN_NEW_WINDOW as u32;
    }
}

impl fmt::Display for PlacesOpenFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for PlacesOpenFlags {
    type GlibType = ffi::GtkPlacesOpenFlags;

    fn into_glib(self) -> ffi::GtkPlacesOpenFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPlacesOpenFlags> for PlacesOpenFlags {
    unsafe fn from_glib(value: ffi::GtkPlacesOpenFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PlacesOpenFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_places_open_flags_get_type()) }
    }
}

impl glib::value::ValueType for PlacesOpenFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PlacesOpenFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PlacesOpenFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkRecentFilterFlags")]
    pub struct RecentFilterFlags: u32 {
        #[doc(alias = "GTK_RECENT_FILTER_URI")]
        const URI = ffi::GTK_RECENT_FILTER_URI as u32;
        #[doc(alias = "GTK_RECENT_FILTER_DISPLAY_NAME")]
        const DISPLAY_NAME = ffi::GTK_RECENT_FILTER_DISPLAY_NAME as u32;
        #[doc(alias = "GTK_RECENT_FILTER_MIME_TYPE")]
        const MIME_TYPE = ffi::GTK_RECENT_FILTER_MIME_TYPE as u32;
        #[doc(alias = "GTK_RECENT_FILTER_APPLICATION")]
        const APPLICATION = ffi::GTK_RECENT_FILTER_APPLICATION as u32;
        #[doc(alias = "GTK_RECENT_FILTER_GROUP")]
        const GROUP = ffi::GTK_RECENT_FILTER_GROUP as u32;
        #[doc(alias = "GTK_RECENT_FILTER_AGE")]
        const AGE = ffi::GTK_RECENT_FILTER_AGE as u32;
    }
}

impl fmt::Display for RecentFilterFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for RecentFilterFlags {
    type GlibType = ffi::GtkRecentFilterFlags;

    fn into_glib(self) -> ffi::GtkRecentFilterFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRecentFilterFlags> for RecentFilterFlags {
    unsafe fn from_glib(value: ffi::GtkRecentFilterFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for RecentFilterFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_recent_filter_flags_get_type()) }
    }
}

impl glib::value::ValueType for RecentFilterFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for RecentFilterFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for RecentFilterFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkRegionFlags")]
    pub struct RegionFlags: u32 {
        #[doc(alias = "GTK_REGION_EVEN")]
        const EVEN = ffi::GTK_REGION_EVEN as u32;
        #[doc(alias = "GTK_REGION_ODD")]
        const ODD = ffi::GTK_REGION_ODD as u32;
        #[doc(alias = "GTK_REGION_FIRST")]
        const FIRST = ffi::GTK_REGION_FIRST as u32;
        #[doc(alias = "GTK_REGION_LAST")]
        const LAST = ffi::GTK_REGION_LAST as u32;
        #[doc(alias = "GTK_REGION_ONLY")]
        const ONLY = ffi::GTK_REGION_ONLY as u32;
        #[doc(alias = "GTK_REGION_SORTED")]
        const SORTED = ffi::GTK_REGION_SORTED as u32;
    }
}

impl fmt::Display for RegionFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for RegionFlags {
    type GlibType = ffi::GtkRegionFlags;

    fn into_glib(self) -> ffi::GtkRegionFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRegionFlags> for RegionFlags {
    unsafe fn from_glib(value: ffi::GtkRegionFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for RegionFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_region_flags_get_type()) }
    }
}

impl glib::value::ValueType for RegionFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for RegionFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for RegionFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkStateFlags")]
    pub struct StateFlags: u32 {
        #[doc(alias = "GTK_STATE_FLAG_NORMAL")]
        const NORMAL = ffi::GTK_STATE_FLAG_NORMAL as u32;
        #[doc(alias = "GTK_STATE_FLAG_ACTIVE")]
        const ACTIVE = ffi::GTK_STATE_FLAG_ACTIVE as u32;
        #[doc(alias = "GTK_STATE_FLAG_PRELIGHT")]
        const PRELIGHT = ffi::GTK_STATE_FLAG_PRELIGHT as u32;
        #[doc(alias = "GTK_STATE_FLAG_SELECTED")]
        const SELECTED = ffi::GTK_STATE_FLAG_SELECTED as u32;
        #[doc(alias = "GTK_STATE_FLAG_INSENSITIVE")]
        const INSENSITIVE = ffi::GTK_STATE_FLAG_INSENSITIVE as u32;
        #[doc(alias = "GTK_STATE_FLAG_INCONSISTENT")]
        const INCONSISTENT = ffi::GTK_STATE_FLAG_INCONSISTENT as u32;
        #[doc(alias = "GTK_STATE_FLAG_FOCUSED")]
        const FOCUSED = ffi::GTK_STATE_FLAG_FOCUSED as u32;
        #[doc(alias = "GTK_STATE_FLAG_BACKDROP")]
        const BACKDROP = ffi::GTK_STATE_FLAG_BACKDROP as u32;
        #[doc(alias = "GTK_STATE_FLAG_DIR_LTR")]
        const DIR_LTR = ffi::GTK_STATE_FLAG_DIR_LTR as u32;
        #[doc(alias = "GTK_STATE_FLAG_DIR_RTL")]
        const DIR_RTL = ffi::GTK_STATE_FLAG_DIR_RTL as u32;
        #[doc(alias = "GTK_STATE_FLAG_LINK")]
        const LINK = ffi::GTK_STATE_FLAG_LINK as u32;
        #[doc(alias = "GTK_STATE_FLAG_VISITED")]
        const VISITED = ffi::GTK_STATE_FLAG_VISITED as u32;
        #[doc(alias = "GTK_STATE_FLAG_CHECKED")]
        const CHECKED = ffi::GTK_STATE_FLAG_CHECKED as u32;
        #[doc(alias = "GTK_STATE_FLAG_DROP_ACTIVE")]
        const DROP_ACTIVE = ffi::GTK_STATE_FLAG_DROP_ACTIVE as u32;
    }
}

impl fmt::Display for StateFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for StateFlags {
    type GlibType = ffi::GtkStateFlags;

    fn into_glib(self) -> ffi::GtkStateFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStateFlags> for StateFlags {
    unsafe fn from_glib(value: ffi::GtkStateFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for StateFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_state_flags_get_type()) }
    }
}

impl glib::value::ValueType for StateFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for StateFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for StateFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
    #[doc(alias = "GtkStyleContextPrintFlags")]
    pub struct StyleContextPrintFlags: u32 {
        #[doc(alias = "GTK_STYLE_CONTEXT_PRINT_NONE")]
        const NONE = ffi::GTK_STYLE_CONTEXT_PRINT_NONE as u32;
        #[doc(alias = "GTK_STYLE_CONTEXT_PRINT_RECURSE")]
        const RECURSE = ffi::GTK_STYLE_CONTEXT_PRINT_RECURSE as u32;
        #[doc(alias = "GTK_STYLE_CONTEXT_PRINT_SHOW_STYLE")]
        const SHOW_STYLE = ffi::GTK_STYLE_CONTEXT_PRINT_SHOW_STYLE as u32;
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl fmt::Display for StyleContextPrintFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
#[doc(hidden)]
impl IntoGlib for StyleContextPrintFlags {
    type GlibType = ffi::GtkStyleContextPrintFlags;

    fn into_glib(self) -> ffi::GtkStyleContextPrintFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
#[doc(hidden)]
impl FromGlib<ffi::GtkStyleContextPrintFlags> for StyleContextPrintFlags {
    unsafe fn from_glib(value: ffi::GtkStyleContextPrintFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl StaticType for StyleContextPrintFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_style_context_print_flags_get_type()) }
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl glib::value::ValueType for StyleContextPrintFlags {
    type Type = Self;
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
unsafe impl<'a> FromValue<'a> for StyleContextPrintFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v3_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
impl ToValue for StyleContextPrintFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkTargetFlags")]
    pub struct TargetFlags: u32 {
        #[doc(alias = "GTK_TARGET_SAME_APP")]
        const SAME_APP = ffi::GTK_TARGET_SAME_APP as u32;
        #[doc(alias = "GTK_TARGET_SAME_WIDGET")]
        const SAME_WIDGET = ffi::GTK_TARGET_SAME_WIDGET as u32;
        #[doc(alias = "GTK_TARGET_OTHER_APP")]
        const OTHER_APP = ffi::GTK_TARGET_OTHER_APP as u32;
        #[doc(alias = "GTK_TARGET_OTHER_WIDGET")]
        const OTHER_WIDGET = ffi::GTK_TARGET_OTHER_WIDGET as u32;
    }
}

impl fmt::Display for TargetFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for TargetFlags {
    type GlibType = ffi::GtkTargetFlags;

    fn into_glib(self) -> ffi::GtkTargetFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTargetFlags> for TargetFlags {
    unsafe fn from_glib(value: ffi::GtkTargetFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for TargetFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_target_flags_get_type()) }
    }
}

impl glib::value::ValueType for TargetFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TargetFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for TargetFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkTextSearchFlags")]
    pub struct TextSearchFlags: u32 {
        #[doc(alias = "GTK_TEXT_SEARCH_VISIBLE_ONLY")]
        const VISIBLE_ONLY = ffi::GTK_TEXT_SEARCH_VISIBLE_ONLY as u32;
        #[doc(alias = "GTK_TEXT_SEARCH_TEXT_ONLY")]
        const TEXT_ONLY = ffi::GTK_TEXT_SEARCH_TEXT_ONLY as u32;
        #[doc(alias = "GTK_TEXT_SEARCH_CASE_INSENSITIVE")]
        const CASE_INSENSITIVE = ffi::GTK_TEXT_SEARCH_CASE_INSENSITIVE as u32;
    }
}

impl fmt::Display for TextSearchFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for TextSearchFlags {
    type GlibType = ffi::GtkTextSearchFlags;

    fn into_glib(self) -> ffi::GtkTextSearchFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextSearchFlags> for TextSearchFlags {
    unsafe fn from_glib(value: ffi::GtkTextSearchFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for TextSearchFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_text_search_flags_get_type()) }
    }
}

impl glib::value::ValueType for TextSearchFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TextSearchFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for TextSearchFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkToolPaletteDragTargets")]
    pub struct ToolPaletteDragTargets: u32 {
        #[doc(alias = "GTK_TOOL_PALETTE_DRAG_ITEMS")]
        const ITEMS = ffi::GTK_TOOL_PALETTE_DRAG_ITEMS as u32;
        #[doc(alias = "GTK_TOOL_PALETTE_DRAG_GROUPS")]
        const GROUPS = ffi::GTK_TOOL_PALETTE_DRAG_GROUPS as u32;
    }
}

impl fmt::Display for ToolPaletteDragTargets {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for ToolPaletteDragTargets {
    type GlibType = ffi::GtkToolPaletteDragTargets;

    fn into_glib(self) -> ffi::GtkToolPaletteDragTargets {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkToolPaletteDragTargets> for ToolPaletteDragTargets {
    unsafe fn from_glib(value: ffi::GtkToolPaletteDragTargets) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ToolPaletteDragTargets {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_tool_palette_drag_targets_get_type()) }
    }
}

impl glib::value::ValueType for ToolPaletteDragTargets {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ToolPaletteDragTargets {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ToolPaletteDragTargets {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GtkTreeModelFlags")]
    pub struct TreeModelFlags: u32 {
        #[doc(alias = "GTK_TREE_MODEL_ITERS_PERSIST")]
        const ITERS_PERSIST = ffi::GTK_TREE_MODEL_ITERS_PERSIST as u32;
        #[doc(alias = "GTK_TREE_MODEL_LIST_ONLY")]
        const LIST_ONLY = ffi::GTK_TREE_MODEL_LIST_ONLY as u32;
    }
}

impl fmt::Display for TreeModelFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for TreeModelFlags {
    type GlibType = ffi::GtkTreeModelFlags;

    fn into_glib(self) -> ffi::GtkTreeModelFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeModelFlags> for TreeModelFlags {
    unsafe fn from_glib(value: ffi::GtkTreeModelFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for TreeModelFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_tree_model_flags_get_type()) }
    }
}

impl glib::value::ValueType for TreeModelFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TreeModelFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for TreeModelFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}
